import random
def isEven(value):
    return bin(value)[-1] == '0'

'''Суть работы функции если копать глубоко схожа. 
Но на высоком уровне мы совершаем разные действия: 
в решении, что дано, сравниваем именно остаток от деления, 
а в моём - крайний бит. Преимуществом моей реализации будет отсутствие 
арифметических действий над числом. Однако есть и недостаток - временная сложность 
появляется во внутрянке функции bin - O(log(N)), и необходимость выделения памяти не 
только под число, но и под его двоичное представление. Я нашел разные сведения касательно 
сложности функции bin(), но считаю что она все таки не константная, ведь предела на хранимое число 
с 3 версии Python если не ошибаюсь нет.'''

def quick_sort(arr):
    """Сортирует массив с помощью быстрой сортировки и возвращает новый отсортированный массив."""
    if len(arr) <= 1:
        return arr  # Если массив пустой или содержит один элемент, он уже отсортирован

    pivot = arr[len(arr) // 2]  # Выбираем опорный элемент (средний элемент)
    left = [x for x in arr if x < pivot]  # Элементы меньше опорного
    middle = [x for x in arr if x == pivot]  # Элементы равные опорному
    right = [x for x in arr if x > pivot]  # Элементы больше опорного

    # Рекурсивно сортируем и объединяем
    return quick_sort(left) + middle + quick_sort(right)
print(quick_sort([random.randint(0, 10000) for _ in range(10)]))